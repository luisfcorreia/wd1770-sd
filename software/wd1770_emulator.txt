/*
 * WD1770 Floppy Disk Controller Emulator for STM32
 * 
 * This code emulates the Western Digital WD1770 FDC chip
 * Pin mappings should be adjusted based on your STM32 board
 * 
 * WD1770 Register Map:
 * 0x00 - Command/Status Register
 * 0x01 - Track Register
 * 0x02 - Sector Register
 * 0x03 - Data Register
 */

#include <Arduino.h>

// WD1770 Register addresses
#define WD1770_CMD_STATUS   0
#define WD1770_TRACK        1
#define WD1770_SECTOR       2
#define WD1770_DATA         3

// Command definitions (Type I - Restore/Seek/Step)
#define CMD_RESTORE         0x00
#define CMD_SEEK            0x10
#define CMD_STEP            0x20
#define CMD_STEP_IN         0x40
#define CMD_STEP_OUT        0x60

// Command definitions (Type II - Read/Write)
#define CMD_READ_SECTOR     0x80
#define CMD_WRITE_SECTOR    0xA0

// Command definitions (Type III - Read Address/Track)
#define CMD_READ_ADDRESS    0xC0
#define CMD_READ_TRACK      0xE0
#define CMD_WRITE_TRACK     0xF0

// Command definitions (Type IV - Force Interrupt)
#define CMD_FORCE_INT       0xD0

// Status register bits
#define STATUS_BUSY         0x01
#define STATUS_DRQ          0x02  // Data Request
#define STATUS_LOST_DATA    0x04
#define STATUS_CRC_ERROR    0x08
#define STATUS_RECORD_NF    0x10  // Record Not Found
#define STATUS_TRACK_0      0x04  // For Type I commands
#define STATUS_INDEX        0x02  // For Type I commands
#define STATUS_WRITE_PROT   0x40
#define STATUS_NOT_READY    0x80

// Pin definitions (adjust for your STM32 board)
#define PIN_CS      PA4    // Chip Select
#define PIN_A0      PA5    // Address bit 0
#define PIN_A1      PA6    // Address bit 1
#define PIN_RD      PA7    // Read strobe
#define PIN_WR      PB0    // Write strobe
#define PIN_DACK    PB1    // DMA Acknowledge
#define PIN_DRQ     PB2    // DMA Request (output)
#define PIN_INTRQ   PB3    // Interrupt Request (output)

// Data bus pins (8-bit)
#define DATA_PIN_START PB4
uint8_t dataPins[] = {PB4, PB5, PB6, PB7, PB8, PB9, PB10, PB11};

// Emulator state
typedef struct {
    uint8_t cmdStatus;
    uint8_t track;
    uint8_t sector;
    uint8_t data;
    uint8_t currentTrack;
    uint8_t direction;
    bool busy;
    bool drq;
    bool intrq;
    uint16_t dataIndex;
    uint8_t sectorBuffer[512];
} WD1770State;

WD1770State fdc;

// Virtual disk image (simplified - 80 tracks, 9 sectors, 512 bytes each)
#define TRACKS      80
#define SECTORS     9
#define SECTOR_SIZE 512
uint8_t diskImage[TRACKS][SECTORS][SECTOR_SIZE];

void setup() {
    Serial.begin(115200);
    Serial.println("WD1770 FDC Emulator Starting...");
    
    // Initialize pins
    pinMode(PIN_CS, INPUT);
    pinMode(PIN_A0, INPUT);
    pinMode(PIN_A1, INPUT);
    pinMode(PIN_RD, INPUT);
    pinMode(PIN_WR, INPUT);
    pinMode(PIN_DACK, INPUT);
    pinMode(PIN_DRQ, OUTPUT);
    pinMode(PIN_INTRQ, OUTPUT);
    
    // Initialize data bus as inputs initially
    for (int i = 0; i < 8; i++) {
        pinMode(dataPins[i], INPUT);
    }
    
    // Initialize FDC state
    initFDC();
    
    Serial.println("WD1770 FDC Emulator Ready");
}

void loop() {
    // Check for chip select
    if (digitalRead(PIN_CS) == LOW) {
        uint8_t addr = (digitalRead(PIN_A1) << 1) | digitalRead(PIN_A0);
        
        // Read operation
        if (digitalRead(PIN_RD) == LOW) {
            handleRead(addr);
        }
        // Write operation
        else if (digitalRead(PIN_WR) == LOW) {
            handleWrite(addr);
        }
    }
    
    // Update status outputs
    digitalWrite(PIN_DRQ, fdc.drq ? HIGH : LOW);
    digitalWrite(PIN_INTRQ, fdc.intrq ? HIGH : LOW);
    
    // Process ongoing commands
    processCommand();
}

void initFDC() {
    fdc.cmdStatus = 0;
    fdc.track = 0;
    fdc.sector = 1;
    fdc.data = 0;
    fdc.currentTrack = 0;
    fdc.direction = 1;
    fdc.busy = false;
    fdc.drq = false;
    fdc.intrq = false;
    fdc.dataIndex = 0;
    
    // Initialize disk image with test pattern
    for (int t = 0; t < TRACKS; t++) {
        for (int s = 0; s < SECTORS; s++) {
            for (int b = 0; b < SECTOR_SIZE; b++) {
                diskImage[t][s][b] = (t + s + b) & 0xFF;
            }
        }
    }
}

void handleRead(uint8_t addr) {
    uint8_t value = 0;
    
    switch (addr) {
        case WD1770_CMD_STATUS:
            value = fdc.cmdStatus;
            fdc.intrq = false; // Clear interrupt on status read
            break;
            
        case WD1770_TRACK:
            value = fdc.track;
            break;
            
        case WD1770_SECTOR:
            value = fdc.sector;
            break;
            
        case WD1770_DATA:
            value = fdc.data;
            if (fdc.drq) {
                // Return next byte from sector buffer
                if (fdc.dataIndex < SECTOR_SIZE) {
                    value = fdc.sectorBuffer[fdc.dataIndex++];
                }
                if (fdc.dataIndex >= SECTOR_SIZE) {
                    fdc.drq = false;
                    fdc.busy = false;
                    fdc.intrq = true;
                }
            }
            break;
    }
    
    // Output value on data bus
    setDataBus(value);
}

void handleWrite(uint8_t addr) {
    uint8_t value = readDataBus();
    
    switch (addr) {
        case WD1770_CMD_STATUS:
            executeCommand(value);
            break;
            
        case WD1770_TRACK:
            fdc.track = value;
            break;
            
        case WD1770_SECTOR:
            fdc.sector = value;
            break;
            
        case WD1770_DATA:
            fdc.data = value;
            if (fdc.drq && fdc.busy) {
                // Write byte to sector buffer
                if (fdc.dataIndex < SECTOR_SIZE) {
                    fdc.sectorBuffer[fdc.dataIndex++] = value;
                }
                if (fdc.dataIndex >= SECTOR_SIZE) {
                    // Write complete sector to disk
                    writeSectorToDisk();
                    fdc.drq = false;
                    fdc.busy = false;
                    fdc.intrq = true;
                }
            }
            break;
    }
}

void executeCommand(uint8_t cmd) {
    uint8_t cmdType = cmd & 0xF0;
    
    fdc.cmdStatus = STATUS_BUSY;
    fdc.busy = true;
    fdc.intrq = false;
    
    Serial.print("Command: 0x");
    Serial.println(cmd, HEX);
    
    if (cmdType == CMD_RESTORE) {
        cmdRestore(cmd);
    }
    else if (cmdType == CMD_SEEK) {
        cmdSeek(cmd);
    }
    else if ((cmdType & 0xE0) == CMD_STEP) {
        cmdStep(cmd);
    }
    else if ((cmd & 0xE0) == CMD_READ_SECTOR) {
        cmdReadSector(cmd);
    }
    else if ((cmd & 0xE0) == CMD_WRITE_SECTOR) {
        cmdWriteSector(cmd);
    }
    else if ((cmd & 0xF0) == CMD_READ_ADDRESS) {
        cmdReadAddress(cmd);
    }
    else if ((cmd & 0xF0) == CMD_FORCE_INT) {
        cmdForceInterrupt(cmd);
    }
}

void cmdRestore(uint8_t cmd) {
    fdc.currentTrack = 0;
    fdc.track = 0;
    fdc.cmdStatus = STATUS_TRACK_0;
    fdc.busy = false;
    fdc.intrq = true;
    
    Serial.println("RESTORE complete");
}

void cmdSeek(uint8_t cmd) {
    fdc.currentTrack = fdc.data;
    
    if (fdc.currentTrack >= TRACKS) {
        fdc.currentTrack = TRACKS - 1;
    }
    
    fdc.cmdStatus = (fdc.currentTrack == 0) ? STATUS_TRACK_0 : 0;
    fdc.track = fdc.currentTrack;
    fdc.busy = false;
    fdc.intrq = true;
    
    Serial.print("SEEK to track ");
    Serial.println(fdc.currentTrack);
}

void cmdStep(uint8_t cmd) {
    uint8_t cmdType = cmd & 0xE0;
    
    if (cmdType == CMD_STEP_IN) {
        fdc.direction = 1;
    } else if (cmdType == CMD_STEP_OUT) {
        fdc.direction = -1;
    }
    
    fdc.currentTrack += fdc.direction;
    
    if (fdc.currentTrack >= TRACKS) {
        fdc.currentTrack = TRACKS - 1;
    }
    if (fdc.currentTrack < 0) {
        fdc.currentTrack = 0;
    }
    
    if (cmd & 0x10) { // Update track register flag
        fdc.track = fdc.currentTrack;
    }
    
    fdc.cmdStatus = (fdc.currentTrack == 0) ? STATUS_TRACK_0 : 0;
    fdc.busy = false;
    fdc.intrq = true;
}

void cmdReadSector(uint8_t cmd) {
    if (fdc.currentTrack >= TRACKS || fdc.sector > SECTORS || fdc.sector == 0) {
        fdc.cmdStatus = STATUS_RECORD_NF;
        fdc.busy = false;
        fdc.intrq = true;
        return;
    }
    
    // Copy sector data to buffer
    memcpy(fdc.sectorBuffer, diskImage[fdc.currentTrack][fdc.sector - 1], SECTOR_SIZE);
    
    fdc.dataIndex = 0;
    fdc.drq = true;
    fdc.cmdStatus = STATUS_BUSY | STATUS_DRQ;
    
    Serial.print("READ SECTOR T:");
    Serial.print(fdc.currentTrack);
    Serial.print(" S:");
    Serial.println(fdc.sector);
}

void cmdWriteSector(uint8_t cmd) {
    if (fdc.currentTrack >= TRACKS || fdc.sector > SECTORS || fdc.sector == 0) {
        fdc.cmdStatus = STATUS_RECORD_NF;
        fdc.busy = false;
        fdc.intrq = true;
        return;
    }
    
    fdc.dataIndex = 0;
    fdc.drq = true;
    fdc.cmdStatus = STATUS_BUSY | STATUS_DRQ;
    
    Serial.print("WRITE SECTOR T:");
    Serial.print(fdc.currentTrack);
    Serial.print(" S:");
    Serial.println(fdc.sector);
}

void cmdReadAddress(uint8_t cmd) {
    // Return current sector address
    fdc.sectorBuffer[0] = fdc.currentTrack;
    fdc.sectorBuffer[1] = 0; // Side
    fdc.sectorBuffer[2] = fdc.sector;
    fdc.sectorBuffer[3] = 2; // Sector size (2 = 512 bytes)
    fdc.sectorBuffer[4] = 0; // CRC1
    fdc.sectorBuffer[5] = 0; // CRC2
    
    fdc.dataIndex = 0;
    fdc.drq = true;
    fdc.cmdStatus = STATUS_BUSY | STATUS_DRQ;
}

void cmdForceInterrupt(uint8_t cmd) {
    fdc.busy = false;
    fdc.drq = false;
    fdc.cmdStatus = 0;
    
    if (cmd & 0x0F) {
        fdc.intrq = true;
    }
    
    Serial.println("FORCE INTERRUPT");
}

void writeSectorToDisk() {
    if (fdc.currentTrack < TRACKS && fdc.sector > 0 && fdc.sector <= SECTORS) {
        memcpy(diskImage[fdc.currentTrack][fdc.sector - 1], fdc.sectorBuffer, SECTOR_SIZE);
        
        Serial.print("Sector written: T:");
        Serial.print(fdc.currentTrack);
        Serial.print(" S:");
        Serial.println(fdc.sector);
    }
}

void processCommand() {
    // This function would handle command timing and state updates
    // In a real implementation, you'd use timers for realistic timing
}

uint8_t readDataBus() {
    uint8_t value = 0;
    for (int i = 0; i < 8; i++) {
        pinMode(dataPins[i], INPUT);
        if (digitalRead(dataPins[i]) == HIGH) {
            value |= (1 << i);
        }
    }
    return value;
}

void setDataBus(uint8_t value) {
    for (int i = 0; i < 8; i++) {
        pinMode(dataPins[i], OUTPUT);
        digitalWrite(dataPins[i], (value & (1 << i)) ? HIGH : LOW);
    }
}
